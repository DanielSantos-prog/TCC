CCS PCH C Compiler, Version 5.007, 61971               15-fev-20 10:37

               Filename:   D:\2 - Engenharia Elétrica - UFT\TCC\Programa\TCC.lst

               ROM used:   5378 bytes (16%)
                           Largest free fragment is 27390
               RAM used:   57 (3%) at main() level
                           104 (5%) worst case
               Stack used: 0 locations
               Stack size: 31

*
0000:  GOTO   0C68
.................... #include<18f4550.h> //inclusão da biblioteca do PIC 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
0004:  CLRF   FF7
0006:  ADDLW  14
0008:  MOVWF  FF6
000A:  MOVLW  00
000C:  ADDWFC FF7,F
000E:  TBLRD*+
0010:  MOVF   FF5,W
0012:  RETURN 0
0014:  DATA 28,0C
0016:  DATA 01,06
0018:  DATA 54,32
001A:  DATA 35,36
001C:  DATA 30,00
001E:  DATA 46,31
0020:  DATA 3A,25
0022:  DATA 2E,31
0024:  DATA 66,56
0026:  DATA 20,25
0028:  DATA 2E,31
002A:  DATA 66,41
002C:  DATA 00,00
002E:  DATA 46,32
0030:  DATA 3A,25
0032:  DATA 2E,31
0034:  DATA 66,56
0036:  DATA 20,25
0038:  DATA 2E,31
003A:  DATA 66,41
003C:  DATA 00,00
003E:  DATA 46,33
0040:  DATA 3A,25
0042:  DATA 2E,31
0044:  DATA 66,56
0046:  DATA 20,25
0048:  DATA 2E,31
004A:  DATA 66,41
004C:  DATA 00,00
*
0204:  MOVLW  8E
0206:  MOVWF  00
0208:  MOVFF  38,01
020C:  MOVFF  37,02
0210:  CLRF   03
0212:  MOVF   01,F
0214:  BNZ   0228
0216:  MOVFF  02,01
021A:  CLRF   02
021C:  MOVLW  08
021E:  SUBWF  00,F
0220:  MOVF   01,F
0222:  BNZ   0228
0224:  CLRF   00
0226:  BRA    0238
0228:  BCF    FD8.0
022A:  BTFSC  01.7
022C:  BRA    0236
022E:  RLCF   02,F
0230:  RLCF   01,F
0232:  DECF   00,F
0234:  BRA    0228
0236:  BCF    01.7
0238:  RETURN 0
023A:  MOVF   5B,W
023C:  BTFSC  FD8.2
023E:  BRA    0322
0240:  MOVWF  00
0242:  MOVF   5F,W
0244:  BTFSC  FD8.2
0246:  BRA    0322
0248:  ADDWF  00,F
024A:  BNC   0254
024C:  MOVLW  81
024E:  ADDWF  00,F
0250:  BC    0322
0252:  BRA    025C
0254:  MOVLW  7F
0256:  SUBWF  00,F
0258:  BNC   0322
025A:  BZ    0322
025C:  MOVFF  5C,63
0260:  MOVF   x60,W
0262:  XORWF  x63,F
0264:  BSF    5C.7
0266:  BSF    x60.7
0268:  MOVF   5E,W
026A:  MULWF  x62
026C:  MOVFF  FF4,65
0270:  MOVF   5D,W
0272:  MULWF  x61
0274:  MOVFF  FF4,03
0278:  MOVFF  FF3,64
027C:  MULWF  x62
027E:  MOVF   FF3,W
0280:  ADDWF  x65,F
0282:  MOVF   FF4,W
0284:  ADDWFC x64,F
0286:  MOVLW  00
0288:  ADDWFC 03,F
028A:  MOVF   5E,W
028C:  MULWF  x61
028E:  MOVF   FF3,W
0290:  ADDWF  x65,F
0292:  MOVF   FF4,W
0294:  ADDWFC x64,F
0296:  MOVLW  00
0298:  CLRF   02
029A:  ADDWFC 03,F
029C:  ADDWFC 02,F
029E:  MOVF   5C,W
02A0:  MULWF  x62
02A2:  MOVF   FF3,W
02A4:  ADDWF  x64,F
02A6:  MOVF   FF4,W
02A8:  ADDWFC 03,F
02AA:  MOVLW  00
02AC:  ADDWFC 02,F
02AE:  MOVF   5C,W
02B0:  MULWF  x61
02B2:  MOVF   FF3,W
02B4:  ADDWF  03,F
02B6:  MOVF   FF4,W
02B8:  ADDWFC 02,F
02BA:  MOVLW  00
02BC:  CLRF   01
02BE:  ADDWFC 01,F
02C0:  MOVF   5E,W
02C2:  MULWF  x60
02C4:  MOVF   FF3,W
02C6:  ADDWF  x64,F
02C8:  MOVF   FF4,W
02CA:  ADDWFC 03,F
02CC:  MOVLW  00
02CE:  ADDWFC 02,F
02D0:  ADDWFC 01,F
02D2:  MOVF   5D,W
02D4:  MULWF  x60
02D6:  MOVF   FF3,W
02D8:  ADDWF  03,F
02DA:  MOVF   FF4,W
02DC:  ADDWFC 02,F
02DE:  MOVLW  00
02E0:  ADDWFC 01,F
02E2:  MOVF   5C,W
02E4:  MULWF  x60
02E6:  MOVF   FF3,W
02E8:  ADDWF  02,F
02EA:  MOVF   FF4,W
02EC:  ADDWFC 01,F
02EE:  INCF   00,F
02F0:  BTFSC  01.7
02F2:  BRA    02FE
02F4:  RLCF   x64,F
02F6:  RLCF   03,F
02F8:  RLCF   02,F
02FA:  RLCF   01,F
02FC:  DECF   00,F
02FE:  MOVLW  00
0300:  BTFSS  x64.7
0302:  BRA    0318
0304:  INCF   03,F
0306:  ADDWFC 02,F
0308:  ADDWFC 01,F
030A:  MOVF   01,W
030C:  BNZ   0318
030E:  MOVF   02,W
0310:  BNZ   0318
0312:  MOVF   03,W
0314:  BNZ   0318
0316:  INCF   00,F
0318:  BTFSC  x63.7
031A:  BSF    01.7
031C:  BTFSS  x63.7
031E:  BCF    01.7
0320:  BRA    032A
0322:  CLRF   00
0324:  CLRF   01
0326:  CLRF   02
0328:  CLRF   03
032A:  RETURN 0
032C:  MOVLW  8E
032E:  MOVWF  00
0330:  MOVF   35,W
0332:  SUBWF  00,F
0334:  MOVFF  36,02
0338:  MOVFF  37,01
033C:  BSF    02.7
033E:  MOVF   00,F
0340:  BZ    0354
0342:  BCF    FD8.0
0344:  MOVF   02,F
0346:  BNZ   034C
0348:  MOVF   01,F
034A:  BZ    0354
034C:  RRCF   02,F
034E:  RRCF   01,F
0350:  DECFSZ 00,F
0352:  BRA    0342
0354:  BTFSS  36.7
0356:  BRA    0362
0358:  COMF   01,F
035A:  COMF   02,F
035C:  INCF   01,F
035E:  BTFSC  FD8.2
0360:  INCF   02,F
0362:  GOTO   0D34 (RETURN)
0366:  CLRF   01
0368:  CLRF   02
036A:  CLRF   00
036C:  CLRF   03
036E:  MOVF   3A,W
0370:  BNZ   0376
0372:  MOVF   39,W
0374:  BZ    03A6
0376:  MOVLW  10
0378:  MOVWF  3B
037A:  BCF    FD8.0
037C:  RLCF   37,F
037E:  RLCF   38,F
0380:  RLCF   00,F
0382:  RLCF   03,F
0384:  MOVF   3A,W
0386:  SUBWF  03,W
0388:  BNZ   038E
038A:  MOVF   39,W
038C:  SUBWF  00,W
038E:  BNC   039E
0390:  MOVF   39,W
0392:  SUBWF  00,F
0394:  BTFSS  FD8.0
0396:  DECF   03,F
0398:  MOVF   3A,W
039A:  SUBWF  03,F
039C:  BSF    FD8.0
039E:  RLCF   01,F
03A0:  RLCF   02,F
03A2:  DECFSZ 3B,F
03A4:  BRA    037A
03A6:  RETURN 0
03A8:  MOVF   39,W
03AA:  BTFSC  FD8.2
03AC:  BRA    04F8
03AE:  MOVWF  45
03B0:  MOVF   3D,W
03B2:  BTFSC  FD8.2
03B4:  BRA    04F8
03B6:  SUBWF  45,F
03B8:  BNC   03C4
03BA:  MOVLW  7F
03BC:  ADDWF  45,F
03BE:  BTFSC  FD8.0
03C0:  BRA    04F8
03C2:  BRA    03D0
03C4:  MOVLW  81
03C6:  SUBWF  45,F
03C8:  BTFSS  FD8.0
03CA:  BRA    04F8
03CC:  BTFSC  FD8.2
03CE:  BRA    04F8
03D0:  MOVFF  45,00
03D4:  CLRF   01
03D6:  CLRF   02
03D8:  CLRF   03
03DA:  CLRF   44
03DC:  MOVFF  3A,43
03E0:  BSF    43.7
03E2:  MOVFF  3B,42
03E6:  MOVFF  3C,41
03EA:  MOVLW  19
03EC:  MOVWF  45
03EE:  MOVF   40,W
03F0:  SUBWF  41,F
03F2:  BC    040E
03F4:  MOVLW  01
03F6:  SUBWF  42,F
03F8:  BC    040E
03FA:  SUBWF  43,F
03FC:  BC    040E
03FE:  SUBWF  44,F
0400:  BC    040E
0402:  INCF   44,F
0404:  INCF   43,F
0406:  INCF   42,F
0408:  MOVF   40,W
040A:  ADDWF  41,F
040C:  BRA    045E
040E:  MOVF   3F,W
0410:  SUBWF  42,F
0412:  BC    0438
0414:  MOVLW  01
0416:  SUBWF  43,F
0418:  BC    0438
041A:  SUBWF  44,F
041C:  BC    0438
041E:  INCF   44,F
0420:  INCF   43,F
0422:  MOVF   3F,W
0424:  ADDWF  42,F
0426:  MOVF   40,W
0428:  ADDWF  41,F
042A:  BNC   045E
042C:  INCF   42,F
042E:  BNZ   045E
0430:  INCF   43,F
0432:  BNZ   045E
0434:  INCF   44,F
0436:  BRA    045E
0438:  MOVF   3E,W
043A:  IORLW  80
043C:  SUBWF  43,F
043E:  BC    045C
0440:  MOVLW  01
0442:  SUBWF  44,F
0444:  BC    045C
0446:  INCF   44,F
0448:  MOVF   3E,W
044A:  IORLW  80
044C:  ADDWF  43,F
044E:  MOVF   3F,W
0450:  ADDWF  42,F
0452:  BNC   0426
0454:  INCF   43,F
0456:  BNZ   0426
0458:  INCF   44,F
045A:  BRA    0426
045C:  BSF    03.0
045E:  DECFSZ 45,F
0460:  BRA    0464
0462:  BRA    047A
0464:  BCF    FD8.0
0466:  RLCF   41,F
0468:  RLCF   42,F
046A:  RLCF   43,F
046C:  RLCF   44,F
046E:  BCF    FD8.0
0470:  RLCF   03,F
0472:  RLCF   02,F
0474:  RLCF   01,F
0476:  RLCF   46,F
0478:  BRA    03EE
047A:  BTFSS  46.0
047C:  BRA    048A
047E:  BCF    FD8.0
0480:  RRCF   01,F
0482:  RRCF   02,F
0484:  RRCF   03,F
0486:  RRCF   46,F
0488:  BRA    048E
048A:  DECF   00,F
048C:  BZ    04F8
048E:  BTFSC  46.7
0490:  BRA    04CE
0492:  BCF    FD8.0
0494:  RLCF   41,F
0496:  RLCF   42,F
0498:  RLCF   43,F
049A:  RLCF   44,F
049C:  MOVF   40,W
049E:  SUBWF  41,F
04A0:  BC    04B0
04A2:  MOVLW  01
04A4:  SUBWF  42,F
04A6:  BC    04B0
04A8:  SUBWF  43,F
04AA:  BC    04B0
04AC:  SUBWF  44,F
04AE:  BNC   04E4
04B0:  MOVF   3F,W
04B2:  SUBWF  42,F
04B4:  BC    04C0
04B6:  MOVLW  01
04B8:  SUBWF  43,F
04BA:  BC    04C0
04BC:  SUBWF  44,F
04BE:  BNC   04E4
04C0:  MOVF   3E,W
04C2:  IORLW  80
04C4:  SUBWF  43,F
04C6:  BC    04CE
04C8:  MOVLW  01
04CA:  SUBWF  44,F
04CC:  BNC   04E4
04CE:  INCF   03,F
04D0:  BNZ   04E4
04D2:  INCF   02,F
04D4:  BNZ   04E4
04D6:  INCF   01,F
04D8:  BNZ   04E4
04DA:  INCF   00,F
04DC:  BZ    04F8
04DE:  RRCF   01,F
04E0:  RRCF   02,F
04E2:  RRCF   03,F
04E4:  MOVFF  3A,45
04E8:  MOVF   3E,W
04EA:  XORWF  45,F
04EC:  BTFSS  45.7
04EE:  BRA    04F4
04F0:  BSF    01.7
04F2:  BRA    0500
04F4:  BCF    01.7
04F6:  BRA    0500
04F8:  CLRF   00
04FA:  CLRF   01
04FC:  CLRF   02
04FE:  CLRF   03
0500:  RETURN 0
0502:  MOVLW  80
0504:  BTFSC  FD8.1
0506:  XORWF  3E,F
0508:  CLRF   43
050A:  CLRF   44
050C:  MOVFF  3A,42
0510:  MOVF   3E,W
0512:  XORWF  42,F
0514:  MOVF   39,W
0516:  BTFSC  FD8.2
0518:  BRA    06D2
051A:  MOVWF  41
051C:  MOVWF  00
051E:  MOVF   3D,W
0520:  BTFSC  FD8.2
0522:  BRA    06E4
0524:  SUBWF  41,F
0526:  BTFSC  FD8.2
0528:  BRA    062C
052A:  BNC   05A6
052C:  MOVFF  3E,47
0530:  BSF    47.7
0532:  MOVFF  3F,46
0536:  MOVFF  40,45
053A:  CLRF   44
053C:  BCF    FD8.0
053E:  RRCF   47,F
0540:  RRCF   46,F
0542:  RRCF   45,F
0544:  RRCF   44,F
0546:  DECFSZ 41,F
0548:  BRA    053A
054A:  BTFSS  42.7
054C:  BRA    0554
054E:  BSF    43.0
0550:  BRA    070C
0552:  BCF    43.0
0554:  BCF    41.0
0556:  BSF    43.4
0558:  CLRF   FEA
055A:  MOVLW  3C
055C:  MOVWF  FE9
055E:  BRA    0732
0560:  BCF    43.4
0562:  BTFSC  42.7
0564:  BRA    057A
0566:  BTFSS  41.0
0568:  BRA    0590
056A:  RRCF   47,F
056C:  RRCF   46,F
056E:  RRCF   45,F
0570:  RRCF   44,F
0572:  INCF   00,F
0574:  BTFSC  FD8.2
0576:  BRA    0702
0578:  BRA    0590
057A:  BTFSC  47.7
057C:  BRA    0596
057E:  BCF    FD8.0
0580:  RLCF   44,F
0582:  RLCF   45,F
0584:  RLCF   46,F
0586:  RLCF   47,F
0588:  DECF   00,F
058A:  BTFSC  FD8.2
058C:  BRA    0702
058E:  BRA    057A
0590:  BSF    43.6
0592:  BRA    066A
0594:  BCF    43.6
0596:  MOVFF  3A,42
059A:  BTFSS  3A.7
059C:  BRA    05A2
059E:  BSF    47.7
05A0:  BRA    06F4
05A2:  BCF    47.7
05A4:  BRA    06F4
05A6:  MOVFF  3D,41
05AA:  MOVFF  3D,00
05AE:  MOVF   39,W
05B0:  SUBWF  41,F
05B2:  MOVFF  3A,47
05B6:  BSF    47.7
05B8:  MOVFF  3B,46
05BC:  MOVFF  3C,45
05C0:  CLRF   44
05C2:  BCF    FD8.0
05C4:  RRCF   47,F
05C6:  RRCF   46,F
05C8:  RRCF   45,F
05CA:  RRCF   44,F
05CC:  DECFSZ 41,F
05CE:  BRA    05C0
05D0:  BTFSS  42.7
05D2:  BRA    05DA
05D4:  BSF    43.1
05D6:  BRA    070C
05D8:  BCF    43.1
05DA:  BCF    41.0
05DC:  BSF    43.5
05DE:  CLRF   FEA
05E0:  MOVLW  40
05E2:  MOVWF  FE9
05E4:  BRA    0732
05E6:  BCF    43.5
05E8:  BTFSC  42.7
05EA:  BRA    0600
05EC:  BTFSS  41.0
05EE:  BRA    0616
05F0:  RRCF   47,F
05F2:  RRCF   46,F
05F4:  RRCF   45,F
05F6:  RRCF   44,F
05F8:  INCF   00,F
05FA:  BTFSC  FD8.2
05FC:  BRA    0702
05FE:  BRA    0616
0600:  BTFSC  47.7
0602:  BRA    061C
0604:  BCF    FD8.0
0606:  RLCF   44,F
0608:  RLCF   45,F
060A:  RLCF   46,F
060C:  RLCF   47,F
060E:  DECF   00,F
0610:  BTFSC  FD8.2
0612:  BRA    0702
0614:  BRA    0600
0616:  BSF    43.7
0618:  BRA    066A
061A:  BCF    43.7
061C:  MOVFF  3E,42
0620:  BTFSS  3E.7
0622:  BRA    0628
0624:  BSF    47.7
0626:  BRA    06F4
0628:  BCF    47.7
062A:  BRA    06F4
062C:  MOVFF  3E,47
0630:  BSF    47.7
0632:  MOVFF  3F,46
0636:  MOVFF  40,45
063A:  BTFSS  42.7
063C:  BRA    0646
063E:  BCF    47.7
0640:  BSF    43.2
0642:  BRA    070C
0644:  BCF    43.2
0646:  CLRF   44
0648:  BCF    41.0
064A:  CLRF   FEA
064C:  MOVLW  3C
064E:  MOVWF  FE9
0650:  BRA    0732
0652:  BTFSC  42.7
0654:  BRA    068E
0656:  MOVFF  3A,42
065A:  BTFSS  41.0
065C:  BRA    066A
065E:  RRCF   47,F
0660:  RRCF   46,F
0662:  RRCF   45,F
0664:  RRCF   44,F
0666:  INCF   00,F
0668:  BZ    0702
066A:  BTFSS  44.7
066C:  BRA    0684
066E:  INCF   45,F
0670:  BNZ   0684
0672:  INCF   46,F
0674:  BNZ   0684
0676:  INCF   47,F
0678:  BNZ   0684
067A:  RRCF   47,F
067C:  RRCF   46,F
067E:  RRCF   45,F
0680:  INCF   00,F
0682:  BZ    0702
0684:  BTFSC  43.6
0686:  BRA    0594
0688:  BTFSC  43.7
068A:  BRA    061A
068C:  BRA    06C6
068E:  MOVLW  80
0690:  XORWF  47,F
0692:  BTFSS  47.7
0694:  BRA    069E
0696:  BRA    070C
0698:  MOVFF  3E,42
069C:  BRA    06B2
069E:  MOVFF  3A,42
06A2:  MOVF   47,F
06A4:  BNZ   06B2
06A6:  MOVF   46,F
06A8:  BNZ   06B2
06AA:  MOVF   45,F
06AC:  BNZ   06B2
06AE:  CLRF   00
06B0:  BRA    06F4
06B2:  BTFSC  47.7
06B4:  BRA    06C6
06B6:  BCF    FD8.0
06B8:  RLCF   44,F
06BA:  RLCF   45,F
06BC:  RLCF   46,F
06BE:  RLCF   47,F
06C0:  DECFSZ 00,F
06C2:  BRA    06B2
06C4:  BRA    0702
06C6:  BTFSS  42.7
06C8:  BRA    06CE
06CA:  BSF    47.7
06CC:  BRA    06F4
06CE:  BCF    47.7
06D0:  BRA    06F4
06D2:  MOVFF  3D,00
06D6:  MOVFF  3E,47
06DA:  MOVFF  3F,46
06DE:  MOVFF  40,45
06E2:  BRA    06F4
06E4:  MOVFF  39,00
06E8:  MOVFF  3A,47
06EC:  MOVFF  3B,46
06F0:  MOVFF  3C,45
06F4:  MOVFF  47,01
06F8:  MOVFF  46,02
06FC:  MOVFF  45,03
0700:  BRA    076A
0702:  CLRF   00
0704:  CLRF   01
0706:  CLRF   02
0708:  CLRF   03
070A:  BRA    076A
070C:  CLRF   44
070E:  COMF   45,F
0710:  COMF   46,F
0712:  COMF   47,F
0714:  COMF   44,F
0716:  INCF   44,F
0718:  BNZ   0724
071A:  INCF   45,F
071C:  BNZ   0724
071E:  INCF   46,F
0720:  BNZ   0724
0722:  INCF   47,F
0724:  BTFSC  43.0
0726:  BRA    0552
0728:  BTFSC  43.1
072A:  BRA    05D8
072C:  BTFSC  43.2
072E:  BRA    0644
0730:  BRA    0698
0732:  MOVF   FEF,W
0734:  ADDWF  45,F
0736:  BNC   0742
0738:  INCF   46,F
073A:  BNZ   0742
073C:  INCF   47,F
073E:  BTFSC  FD8.2
0740:  BSF    41.0
0742:  MOVF   FED,F
0744:  MOVF   FEF,W
0746:  ADDWF  46,F
0748:  BNC   0750
074A:  INCF   47,F
074C:  BTFSC  FD8.2
074E:  BSF    41.0
0750:  MOVF   FED,F
0752:  MOVF   FEF,W
0754:  BTFSC  FEF.7
0756:  BRA    075A
0758:  XORLW  80
075A:  ADDWF  47,F
075C:  BTFSC  FD8.0
075E:  BSF    41.0
0760:  BTFSC  43.4
0762:  BRA    0560
0764:  BTFSC  43.5
0766:  BRA    05E6
0768:  BRA    0652
076A:  RETURN 0
076C:  MOVFF  36,3D
0770:  MOVF   3A,W
0772:  XORWF  3D,F
0774:  BTFSS  3D.7
0776:  BRA    0782
0778:  BCF    FD8.2
077A:  BCF    FD8.0
077C:  BTFSC  36.7
077E:  BSF    FD8.0
0780:  BRA    07E0
0782:  MOVFF  36,3D
0786:  MOVFF  39,3E
078A:  MOVF   35,W
078C:  SUBWF  3E,F
078E:  BZ    079C
0790:  BTFSS  3D.7
0792:  BRA    07E0
0794:  MOVF   FD8,W
0796:  XORLW  01
0798:  MOVWF  FD8
079A:  BRA    07E0
079C:  MOVFF  3A,3E
07A0:  MOVF   36,W
07A2:  SUBWF  3E,F
07A4:  BZ    07B2
07A6:  BTFSS  3D.7
07A8:  BRA    07E0
07AA:  MOVF   FD8,W
07AC:  XORLW  01
07AE:  MOVWF  FD8
07B0:  BRA    07E0
07B2:  MOVFF  3B,3E
07B6:  MOVF   37,W
07B8:  SUBWF  3E,F
07BA:  BZ    07C8
07BC:  BTFSS  3D.7
07BE:  BRA    07E0
07C0:  MOVF   FD8,W
07C2:  XORLW  01
07C4:  MOVWF  FD8
07C6:  BRA    07E0
07C8:  MOVFF  3C,3E
07CC:  MOVF   38,W
07CE:  SUBWF  3E,F
07D0:  BZ    07DE
07D2:  BTFSS  3D.7
07D4:  BRA    07E0
07D6:  MOVF   FD8,W
07D8:  XORLW  01
07DA:  MOVWF  FD8
07DC:  BRA    07E0
07DE:  BCF    FD8.0
07E0:  RETURN 0
*
0854:  TBLRD*+
0856:  MOVF   FF5,F
0858:  BZ    0872
085A:  MOVFF  FF6,4E
085E:  MOVFF  FF7,4F
0862:  MOVFF  FF5,5B
0866:  RCALL  0804
0868:  MOVFF  4E,FF6
086C:  MOVFF  4F,FF7
0870:  BRA    0854
0872:  GOTO   0B18 (RETURN)
0876:  MOVF   FEF,F
0878:  BZ    0898
087A:  MOVFF  FEA,4F
087E:  MOVFF  FE9,4E
0882:  MOVFF  FEF,5B
0886:  RCALL  0804
0888:  MOVFF  4F,FEA
088C:  MOVFF  4E,FE9
0890:  INCF   FE9,F
0892:  BTFSC  FD8.2
0894:  INCF   FEA,F
0896:  BRA    0876
0898:  GOTO   0B2A (RETURN)
089C:  TBLRD*+
089E:  MOVFF  FF6,4F
08A2:  MOVFF  FF7,50
08A6:  MOVFF  FF5,5B
08AA:  RCALL  0804
08AC:  MOVFF  4F,FF6
08B0:  MOVFF  50,FF7
08B4:  DECFSZ 4E,F
08B6:  BRA    089C
08B8:  RETURN 0
08BA:  MOVF   5B,W
08BC:  SUBLW  B6
08BE:  MOVWF  5B
08C0:  CLRF   03
08C2:  MOVFF  5C,5F
08C6:  BSF    5C.7
08C8:  BCF    FD8.0
08CA:  RRCF   5C,F
08CC:  RRCF   5D,F
08CE:  RRCF   5E,F
08D0:  RRCF   03,F
08D2:  RRCF   02,F
08D4:  RRCF   01,F
08D6:  RRCF   00,F
08D8:  DECFSZ 5B,F
08DA:  BRA    08C8
08DC:  BTFSS  5F.7
08DE:  BRA    08F6
08E0:  COMF   00,F
08E2:  COMF   01,F
08E4:  COMF   02,F
08E6:  COMF   03,F
08E8:  INCF   00,F
08EA:  BTFSC  FD8.2
08EC:  INCF   01,F
08EE:  BTFSC  FD8.2
08F0:  INCF   02,F
08F2:  BTFSC  FD8.2
08F4:  INCF   03,F
08F6:  GOTO   09D6 (RETURN)
08FA:  BTFSC  FD8.1
08FC:  BRA    0904
08FE:  CLRF   FEA
0900:  MOVLW  63
0902:  MOVWF  FE9
0904:  CLRF   00
0906:  CLRF   01
0908:  CLRF   02
090A:  CLRF   03
090C:  CLRF   x63
090E:  CLRF   x64
0910:  CLRF   x65
0912:  CLRF   x66
0914:  MOVF   x62,W
0916:  IORWF  x61,W
0918:  IORWF  x60,W
091A:  IORWF  5F,W
091C:  BZ    0976
091E:  MOVLW  20
0920:  MOVWF  x67
0922:  BCF    FD8.0
0924:  RLCF   5B,F
0926:  RLCF   5C,F
0928:  RLCF   5D,F
092A:  RLCF   5E,F
092C:  RLCF   x63,F
092E:  RLCF   x64,F
0930:  RLCF   x65,F
0932:  RLCF   x66,F
0934:  MOVF   x62,W
0936:  SUBWF  x66,W
0938:  BNZ   094A
093A:  MOVF   x61,W
093C:  SUBWF  x65,W
093E:  BNZ   094A
0940:  MOVF   x60,W
0942:  SUBWF  x64,W
0944:  BNZ   094A
0946:  MOVF   5F,W
0948:  SUBWF  x63,W
094A:  BNC   096A
094C:  MOVF   5F,W
094E:  SUBWF  x63,F
0950:  MOVF   x60,W
0952:  BTFSS  FD8.0
0954:  INCFSZ x60,W
0956:  SUBWF  x64,F
0958:  MOVF   x61,W
095A:  BTFSS  FD8.0
095C:  INCFSZ x61,W
095E:  SUBWF  x65,F
0960:  MOVF   x62,W
0962:  BTFSS  FD8.0
0964:  INCFSZ x62,W
0966:  SUBWF  x66,F
0968:  BSF    FD8.0
096A:  RLCF   00,F
096C:  RLCF   01,F
096E:  RLCF   02,F
0970:  RLCF   03,F
0972:  DECFSZ x67,F
0974:  BRA    0922
0976:  MOVFF  63,FEF
097A:  MOVFF  64,FEC
097E:  MOVFF  65,FEC
0982:  MOVFF  66,FEC
0986:  RETURN 0
0988:  MOVF   FE9,W
098A:  MOVWF  53
098C:  MOVF   52,W
098E:  MOVWF  55
0990:  BZ    09C4
0992:  MOVFF  51,5E
0996:  MOVFF  50,5D
099A:  MOVFF  4F,5C
099E:  MOVFF  4E,5B
09A2:  CLRF   x62
09A4:  CLRF   x61
09A6:  MOVLW  20
09A8:  MOVWF  x60
09AA:  MOVLW  82
09AC:  MOVWF  5F
09AE:  RCALL  023A
09B0:  MOVFF  03,51
09B4:  MOVFF  02,50
09B8:  MOVFF  01,4F
09BC:  MOVFF  00,4E
09C0:  DECFSZ 55,F
09C2:  BRA    0992
09C4:  MOVFF  51,5E
09C8:  MOVFF  50,5D
09CC:  MOVFF  4F,5C
09D0:  MOVFF  4E,5B
09D4:  BRA    08BA
09D6:  MOVFF  03,51
09DA:  MOVFF  02,50
09DE:  MOVFF  01,4F
09E2:  MOVFF  00,4E
09E6:  BTFSS  51.7
09E8:  BRA    0A04
09EA:  DECF   53,F
09EC:  BSF    53.5
09EE:  COMF   4E,F
09F0:  COMF   4F,F
09F2:  COMF   50,F
09F4:  COMF   51,F
09F6:  INCF   4E,F
09F8:  BTFSC  FD8.2
09FA:  INCF   4F,F
09FC:  BTFSC  FD8.2
09FE:  INCF   50,F
0A00:  BTFSC  FD8.2
0A02:  INCF   51,F
0A04:  MOVLW  3B
0A06:  MOVWF  5A
0A08:  MOVLW  9A
0A0A:  MOVWF  59
0A0C:  MOVLW  CA
0A0E:  MOVWF  58
0A10:  CLRF   57
0A12:  MOVLW  0A
0A14:  MOVWF  55
0A16:  MOVF   52,W
0A18:  BTFSC  FD8.2
0A1A:  INCF   53,F
0A1C:  BSF    FD8.1
0A1E:  CLRF   FEA
0A20:  MOVLW  4E
0A22:  MOVWF  FE9
0A24:  MOVFF  51,5E
0A28:  MOVFF  50,5D
0A2C:  MOVFF  4F,5C
0A30:  MOVFF  4E,5B
0A34:  MOVFF  5A,62
0A38:  MOVFF  59,61
0A3C:  MOVFF  58,60
0A40:  MOVFF  57,5F
0A44:  RCALL  08FA
0A46:  MOVF   01,W
0A48:  MOVF   00,F
0A4A:  BNZ   0A6A
0A4C:  INCF   52,W
0A4E:  SUBWF  55,W
0A50:  BZ    0A6A
0A52:  MOVF   53,W
0A54:  BZ    0A6E
0A56:  ANDLW  0F
0A58:  SUBWF  55,W
0A5A:  BZ    0A5E
0A5C:  BC    0ACC
0A5E:  BTFSC  53.7
0A60:  BRA    0ACC
0A62:  BTFSC  53.6
0A64:  BRA    0A6E
0A66:  MOVLW  20
0A68:  BRA    0AC4
0A6A:  MOVLW  20
0A6C:  ANDWF  53,F
0A6E:  BTFSS  53.5
0A70:  BRA    0A8A
0A72:  BCF    53.5
0A74:  MOVF   52,W
0A76:  BTFSS  FD8.2
0A78:  DECF   53,F
0A7A:  MOVF   00,W
0A7C:  MOVWF  53
0A7E:  MOVLW  2D
0A80:  MOVWF  5B
0A82:  RCALL  0804
0A84:  MOVF   53,W
0A86:  MOVWF  00
0A88:  CLRF   53
0A8A:  MOVF   52,W
0A8C:  SUBWF  55,W
0A8E:  BNZ   0AA4
0A90:  MOVF   00,W
0A92:  MOVWF  53
0A94:  MOVLW  2E
0A96:  MOVWF  5B
0A98:  RCALL  0804
0A9A:  MOVF   53,W
0A9C:  MOVWF  00
0A9E:  MOVLW  20
0AA0:  ANDWF  53,F
0AA2:  MOVLW  00
0AA4:  MOVLW  30
0AA6:  BTFSS  53.5
0AA8:  BRA    0AC4
0AAA:  BCF    53.5
0AAC:  MOVF   52,W
0AAE:  BTFSS  FD8.2
0AB0:  DECF   53,F
0AB2:  MOVF   00,W
0AB4:  MOVWF  53
0AB6:  MOVLW  2D
0AB8:  MOVWF  5B
0ABA:  RCALL  0804
0ABC:  MOVF   53,W
0ABE:  MOVWF  00
0AC0:  CLRF   53
0AC2:  MOVLW  30
0AC4:  ADDWF  00,F
0AC6:  MOVFF  00,5B
0ACA:  RCALL  0804
0ACC:  BCF    FD8.1
0ACE:  MOVFF  5A,5E
0AD2:  MOVFF  59,5D
0AD6:  MOVFF  58,5C
0ADA:  MOVFF  57,5B
0ADE:  CLRF   x62
0AE0:  CLRF   x61
0AE2:  CLRF   x60
0AE4:  MOVLW  0A
0AE6:  MOVWF  5F
0AE8:  RCALL  08FA
0AEA:  MOVFF  03,5A
0AEE:  MOVFF  02,59
0AF2:  MOVFF  01,58
0AF6:  MOVFF  00,57
0AFA:  DECFSZ 55,F
0AFC:  BRA    0A1C
0AFE:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses INTRC // função que habilita oscilador interno 
.................... #fuses NOWDT   //Sem Watch dog, evitando reset 
.................... #fuses NOPROTECT  //Codigo sem proteção de leitura, software livre! 
.................... #fuses NODEBUG  //No Debug mode for ICD 
....................  
.................... #device ADC=10 
....................  
.................... #use delay(clock=8000000) // define o clock como 8MHz 
*
004E:  CLRF   FEA
0050:  MOVLW  5C
0052:  MOVWF  FE9
0054:  MOVF   FEF,W
0056:  BZ    0072
0058:  MOVLW  02
005A:  MOVWF  01
005C:  CLRF   00
005E:  DECFSZ 00,F
0060:  BRA    005E
0062:  DECFSZ 01,F
0064:  BRA    005C
0066:  MOVLW  97
0068:  MOVWF  00
006A:  DECFSZ 00,F
006C:  BRA    006A
006E:  DECFSZ FEF,F
0070:  BRA    0058
0072:  RETURN 0
....................  
.................... //define as portas para LCD 
.................... #define LCD_ENABLE_PIN  PIN_B3                                     
.................... #define LCD_RS_PIN      PIN_D0                                     
.................... #define LCD_RW_PIN      PIN_B2                                     
.................... #define LCD_DATA4       PIN_B4                                     
.................... #define LCD_DATA5       PIN_B5                                     
.................... #define LCD_DATA6       PIN_B6                                     
.................... #define LCD_DATA7       PIN_B7  
....................  
.................... #use I2C(MASTER, I2C1, SLOW = 100000, STREAM = DS1307_STREAM) 
.................... #include <DS1307.c>  // inclui biblioteca DS1307  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                             DS1307.c                              //// 
.................... ////                                                                   //// 
.................... ////                      Driver for CCS C compiler                    //// 
.................... ////                                                                   //// 
.................... ////     Driver for Maxim DS1307 serial I2C real-time clock (RTC).     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                     https://simple-circuit.com/                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #if defined DS1307_I2C_NO_STREAM 
....................   #define RTC_I2C_START()   i2c_start() 
....................   #define RTC_I2C_STOP()    i2c_stop() 
....................   #define RTC_I2C_WRITE(x)  i2c_write(x) 
....................   #define RTC_I2C_READ(x)   i2c_read(x) 
.................... #elif defined DS1307_I2C_STREAM 
....................   #define RTC_I2C_START()   i2c_start(DS1307_I2C_STREAM) 
....................   #define RTC_I2C_STOP()    i2c_stop(DS1307_I2C_STREAM) 
....................   #define RTC_I2C_WRITE(x)  i2c_write(DS1307_I2C_STREAM, x) 
....................   #define RTC_I2C_READ(x)   i2c_read(DS1307_I2C_STREAM, x) 
.................... #else 
....................   #define RTC_I2C_START()   i2c_start(DS1307_STREAM) 
....................   #define RTC_I2C_STOP()    i2c_stop(DS1307_STREAM) 
....................   #define RTC_I2C_WRITE(x)  i2c_write(DS1307_STREAM, x) 
....................   #define RTC_I2C_READ(x)   i2c_read(DS1307_STREAM, x) 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define DS1307_ADDRESS      0xD0 
.................... #define DS1307_REG_SECONDS  0x00 
.................... #define DS1307_REG_CONTROL  0x07 
....................  
.................... enum SQWE 
.................... { 
....................   OUT_OFF = 0x00, 
....................   OUT_ON  = 0x80, 
....................   OUT_1Hz = 0x10, 
....................   OUT_4096Hz  = 0x11, 
....................   OUT_8192Hz  = 0x12, 
....................   OUT_32768Hz = 0x13 
.................... }; 
....................  
.................... typedef enum 
.................... { 
....................   SUNDAY = 1, 
....................   MONDAY, 
....................   TUESDAY, 
....................   WEDNESDAY, 
....................   THURSDAY, 
....................   FRIDAY, 
....................   SATURDAY 
.................... } RTC_DOW; 
....................  
.................... typedef enum 
.................... { 
....................   JANUARY = 1, 
....................   FEBRUARY, 
....................   MARCH, 
....................   APRIL, 
....................   MAY, 
....................   JUNE, 
....................   JULY, 
....................   AUGUST, 
....................   SEPTEMBER, 
....................   OCTOBER, 
....................   NOVEMBER, 
....................   DECEMBER 
.................... } RTC_Month; 
....................  
.................... typedef struct rtc_tm 
.................... { 
....................   uint8_t seconds; 
....................   uint8_t minutes; 
....................   uint8_t hours; 
....................   RTC_DOW dow; 
....................   uint8_t day; 
....................   RTC_Month month; 
....................   uint8_t year; 
.................... } RTC_Time; 
....................  
.................... ///////////////////////// All Functions ///////////////////////// 
....................                                                                // 
.................... uint8_t bcd_to_decimal(uint8_t number);                        // 
.................... uint8_t decimal_to_bcd(uint8_t number);                        // 
.................... void RTC_Set(RTC_Time *time_t);                                // 
.................... RTC_Time *RTC_Get();                                           // 
.................... void OSC_Enable();                                             // 
.................... void OSC_Disable();                                            // 
.................... uint8_t RTC_Read_Reg(uint8_t reg_address);                     // 
.................... void RTC_Write_Reg(uint8_t reg_address, uint8_t reg_value);    // 
.................... void SQWE_Set(SQWE pin_out);                                   // 
....................                                                                // 
.................... ///////////////////////////////////////////////////////////////// 
....................  
.................... // converts BCD to decimal 
.................... uint8_t bcd_to_decimal(uint8_t number) 
.................... { 
....................   return ( (number >> 4) * 10 + (number & 0x0F) ); 
.................... } 
....................  
.................... // converts decimal to BCD 
.................... uint8_t decimal_to_bcd(uint8_t number) 
.................... { 
....................   return ( ((number / 10) << 4) + (number % 10) ); 
.................... } 
....................  
.................... // sets time and date 
.................... void RTC_Set(RTC_Time *time_t) 
.................... { 
....................   uint8_t sec_reg = RTC_Read_Reg(DS1307_REG_SECONDS); 
....................  
....................   // convert decimal to BCD 
....................   time_t->day     = decimal_to_bcd(time_t->day); 
....................   time_t->month   = decimal_to_bcd(time_t->month); 
....................   time_t->year    = decimal_to_bcd(time_t->year); 
....................   time_t->hours   = decimal_to_bcd(time_t->hours); 
....................   time_t->minutes = decimal_to_bcd(time_t->minutes); 
....................   time_t->seconds = decimal_to_bcd(time_t->seconds); 
....................   // end conversion 
....................    
....................   // test if oscillator is disabled (CH bit = 1) 
....................   if(sec_reg & 0x80) 
....................     time_t->seconds |= 0x80; 
....................  
....................   // write data to the RTC chip 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS); 
....................   RTC_I2C_WRITE(DS1307_REG_SECONDS); 
....................   RTC_I2C_WRITE(time_t->seconds); 
....................   RTC_I2C_WRITE(time_t->minutes); 
....................   RTC_I2C_WRITE(time_t->hours); 
....................   RTC_I2C_WRITE(time_t->dow); 
....................   RTC_I2C_WRITE(time_t->day); 
....................   RTC_I2C_WRITE(time_t->month); 
....................   RTC_I2C_WRITE(time_t->year); 
....................   RTC_I2C_STOP(); 
.................... } 
....................  
.................... RTC_Time c_time; 
....................  
.................... // reads time and date 
.................... RTC_Time *RTC_Get() 
.................... { 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS); 
....................   RTC_I2C_WRITE(DS1307_REG_SECONDS); 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS | 0x01); 
....................   c_time.seconds = RTC_I2C_READ(1) & 0x7F; 
....................   c_time.minutes = RTC_I2C_READ(1); 
....................   c_time.hours   = RTC_I2C_READ(1); 
....................   c_time.dow   = RTC_I2C_READ(1); 
....................   c_time.day   = RTC_I2C_READ(1); 
....................   c_time.month = RTC_I2C_READ(1); 
....................   c_time.year  = RTC_I2C_READ(0); 
....................   RTC_I2C_STOP(); 
....................  
....................   // convert BCD to decimal 
....................   c_time.seconds = bcd_to_decimal(c_time.seconds); 
....................   c_time.minutes = bcd_to_decimal(c_time.minutes); 
....................   c_time.hours   = bcd_to_decimal(c_time.hours); 
....................   c_time.day     = bcd_to_decimal(c_time.day); 
....................   c_time.month   = bcd_to_decimal(c_time.month); 
....................   c_time.year    = bcd_to_decimal(c_time.year); 
....................   // end conversion 
....................  
....................   return &c_time; 
.................... } 
....................  
.................... // writes 'reg_value' to register of address 'reg_address' 
.................... void RTC_Write_Reg(uint8_t reg_address, uint8_t reg_value) 
.................... { 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS); 
....................   RTC_I2C_WRITE(reg_address); 
....................   RTC_I2C_WRITE(reg_value); 
....................   RTC_I2C_STOP(); 
.................... } 
....................  
.................... // returns the value stored in register of address 'reg_address' 
.................... uint8_t RTC_Read_Reg(uint8_t reg_address) 
.................... { 
....................   uint8_t reg_data; 
....................  
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS); 
....................   RTC_I2C_WRITE(reg_address); 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS | 0x01); 
....................   reg_data = RTC_I2C_READ(0); 
....................   RTC_I2C_STOP(); 
....................  
....................   return reg_data; 
.................... } 
....................  
.................... // sets SQWE pin output 
.................... void SQWE_Set(SQWE pin_out) 
.................... { 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS1307_ADDRESS); 
....................   RTC_I2C_WRITE(DS1307_REG_CONTROL); 
....................   RTC_I2C_WRITE(pin_out); 
....................   RTC_I2C_STOP(); 
.................... } 
....................  
.................... // enables RTC oscillator 
.................... void OSC_Enable() 
.................... { 
....................   uint8_t sec_reg = RTC_Read_Reg(DS1307_REG_SECONDS); 
....................   sec_reg &= 0x7F; 
....................   RTC_Write_Reg(DS1307_REG_SECONDS, sec_reg); 
.................... } 
....................  
.................... // disables RTC oscillator 
.................... void OSC_Disable() 
.................... { 
....................   uint8_t sec_reg = RTC_Read_Reg(DS1307_REG_SECONDS); 
....................   sec_reg |= 0x80; 
....................   RTC_Write_Reg(DS1307_REG_SECONDS, sec_reg); 
.................... } 
....................  
.................... #include<lcd.c> // inclui biblioteca LCD 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0106:  BSF    F93.4
....................    output_float(LCD_DATA5); 
0108:  BSF    F93.5
....................    output_float(LCD_DATA6); 
010A:  BSF    F93.6
....................    output_float(LCD_DATA7); 
010C:  BSF    F93.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
010E:  BSF    F8A.2
0110:  BCF    F93.2
....................    delay_cycles(1); 
0112:  NOP   
....................    lcd_output_enable(1); 
0114:  BSF    F8A.3
0116:  BCF    F93.3
....................    delay_cycles(1); 
0118:  NOP   
....................    high = lcd_read_nibble(); 
011A:  RCALL  00B4
011C:  MOVFF  01,63
....................        
....................    lcd_output_enable(0); 
0120:  BCF    F8A.3
0122:  BCF    F93.3
....................    delay_cycles(1); 
0124:  NOP   
....................    lcd_output_enable(1); 
0126:  BSF    F8A.3
0128:  BCF    F93.3
....................    delay_us(1); 
012A:  BRA    012C
....................    low = lcd_read_nibble(); 
012C:  RCALL  00B4
012E:  MOVFF  01,62
....................        
....................    lcd_output_enable(0); 
0132:  BCF    F8A.3
0134:  BCF    F93.3
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0136:  BCF    F93.4
....................    output_drive(LCD_DATA5); 
0138:  BCF    F93.5
....................    output_drive(LCD_DATA6); 
013A:  BCF    F93.6
....................    output_drive(LCD_DATA7); 
013C:  BCF    F93.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
013E:  SWAPF  x63,W
0140:  MOVWF  00
0142:  MOVLW  F0
0144:  ANDWF  00,F
0146:  MOVF   00,W
0148:  IORWF  x62,W
014A:  MOVWF  01
014C:  GOTO   015C (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00B4:  CLRF   x64
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00B6:  BSF    F93.4
00B8:  MOVLW  00
00BA:  BTFSC  F81.4
00BC:  MOVLW  01
00BE:  IORWF  x64,F
....................    n |= input(LCD_DATA5) << 1; 
00C0:  BSF    F93.5
00C2:  MOVLW  00
00C4:  BTFSC  F81.5
00C6:  MOVLW  01
00C8:  MOVWF  00
00CA:  BCF    FD8.0
00CC:  RLCF   00,F
00CE:  MOVF   00,W
00D0:  IORWF  x64,F
....................    n |= input(LCD_DATA6) << 2; 
00D2:  BSF    F93.6
00D4:  MOVLW  00
00D6:  BTFSC  F81.6
00D8:  MOVLW  01
00DA:  MOVWF  00
00DC:  RLCF   00,F
00DE:  RLCF   00,F
00E0:  MOVLW  FC
00E2:  ANDWF  00,F
00E4:  MOVF   00,W
00E6:  IORWF  x64,F
....................    n |= input(LCD_DATA7) << 3; 
00E8:  BSF    F93.7
00EA:  MOVLW  00
00EC:  BTFSC  F81.7
00EE:  MOVLW  01
00F0:  MOVWF  00
00F2:  RLCF   00,F
00F4:  RLCF   00,F
00F6:  RLCF   00,F
00F8:  MOVLW  F8
00FA:  ANDWF  00,F
00FC:  MOVF   00,W
00FE:  IORWF  x64,F
....................     
....................    return(n); 
0100:  MOVFF  64,01
....................   #else 
0104:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0074:  BTFSC  x63.0
0076:  BRA    007C
0078:  BCF    F8A.4
007A:  BRA    007E
007C:  BSF    F8A.4
007E:  BCF    F93.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0080:  BTFSC  x63.1
0082:  BRA    0088
0084:  BCF    F8A.5
0086:  BRA    008A
0088:  BSF    F8A.5
008A:  BCF    F93.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
008C:  BTFSC  x63.2
008E:  BRA    0094
0090:  BCF    F8A.6
0092:  BRA    0096
0094:  BSF    F8A.6
0096:  BCF    F93.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0098:  BTFSC  x63.3
009A:  BRA    00A0
009C:  BCF    F8A.7
009E:  BRA    00A2
00A0:  BSF    F8A.7
00A2:  BCF    F93.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00A4:  NOP   
....................    lcd_output_enable(1); 
00A6:  BSF    F8A.3
00A8:  BCF    F93.3
....................    delay_us(2); 
00AA:  BRA    00AC
00AC:  BRA    00AE
....................    lcd_output_enable(0); 
00AE:  BCF    F8A.3
00B0:  BCF    F93.3
00B2:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0150:  BCF    F93.3
....................    lcd_rs_tris(); 
0152:  BCF    F95.0
....................    lcd_rw_tris(); 
0154:  BCF    F93.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0156:  BCF    F8C.0
0158:  BCF    F95.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
015A:  BRA    0106
015C:  MOVFF  01,62
0160:  BTFSC  01.7
0162:  BRA    015A
....................    lcd_output_rs(address); 
0164:  MOVF   x60,F
0166:  BNZ   016C
0168:  BCF    F8C.0
016A:  BRA    016E
016C:  BSF    F8C.0
016E:  BCF    F95.0
....................    delay_cycles(1); 
0170:  NOP   
....................    lcd_output_rw(0); 
0172:  BCF    F8A.2
0174:  BCF    F93.2
....................    delay_cycles(1); 
0176:  NOP   
....................    lcd_output_enable(0); 
0178:  BCF    F8A.3
017A:  BCF    F93.3
....................    lcd_send_nibble(n >> 4); 
017C:  SWAPF  x61,W
017E:  MOVWF  x62
0180:  MOVLW  0F
0182:  ANDWF  x62,F
0184:  MOVFF  62,63
0188:  RCALL  0074
....................    lcd_send_nibble(n & 0xf); 
018A:  MOVF   x61,W
018C:  ANDLW  0F
018E:  MOVWF  x62
0190:  MOVWF  x63
0192:  RCALL  0074
0194:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0196:  BCF    F93.4
....................    output_drive(LCD_DATA5); 
0198:  BCF    F93.5
....................    output_drive(LCD_DATA6); 
019A:  BCF    F93.6
....................    output_drive(LCD_DATA7); 
019C:  BCF    F93.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
019E:  BCF    F93.3
....................    lcd_rs_tris(); 
01A0:  BCF    F95.0
....................    lcd_rw_tris(); 
01A2:  BCF    F93.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
01A4:  BCF    F8C.0
01A6:  BCF    F95.0
....................    lcd_output_rw(0); 
01A8:  BCF    F8A.2
01AA:  BCF    F93.2
....................    lcd_output_enable(0); 
01AC:  BCF    F8A.3
01AE:  BCF    F93.3
....................      
....................    delay_ms(15); 
01B0:  MOVLW  0F
01B2:  MOVWF  5C
01B4:  RCALL  004E
....................    for(i=1;i<=3;++i) 
01B6:  MOVLW  01
01B8:  MOVWF  35
01BA:  MOVF   35,W
01BC:  SUBLW  03
01BE:  BNC   01D0
....................    { 
....................        lcd_send_nibble(3); 
01C0:  MOVLW  03
01C2:  MOVWF  x63
01C4:  RCALL  0074
....................        delay_ms(5); 
01C6:  MOVLW  05
01C8:  MOVWF  5C
01CA:  RCALL  004E
01CC:  INCF   35,F
01CE:  BRA    01BA
....................    } 
....................     
....................    lcd_send_nibble(2); 
01D0:  MOVLW  02
01D2:  MOVWF  x63
01D4:  RCALL  0074
....................    delay_ms(5); 
01D6:  MOVLW  05
01D8:  MOVWF  5C
01DA:  RCALL  004E
....................    for(i=0;i<=3;++i) 
01DC:  CLRF   35
01DE:  MOVF   35,W
01E0:  SUBLW  03
01E2:  BNC   0200
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
01E4:  CLRF   03
01E6:  MOVF   35,W
01E8:  MOVFF  FF2,36
01EC:  BCF    FF2.7
01EE:  RCALL  0004
01F0:  BTFSC  36.7
01F2:  BSF    FF2.7
01F4:  MOVWF  36
01F6:  CLRF   x60
01F8:  MOVWF  x61
01FA:  RCALL  0150
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01FC:  INCF   35,F
01FE:  BRA    01DE
0200:  GOTO   0CC6 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
07E2:  DECFSZ 5D,W
07E4:  BRA    07E8
07E6:  BRA    07EE
....................       address=LCD_LINE_TWO; 
07E8:  MOVLW  40
07EA:  MOVWF  5E
07EC:  BRA    07F0
....................    else 
....................       address=0; 
07EE:  CLRF   5E
....................       
....................    address+=x-1; 
07F0:  MOVLW  01
07F2:  SUBWF  5C,W
07F4:  ADDWF  5E,F
....................    lcd_send_byte(0,0x80|address); 
07F6:  MOVF   5E,W
07F8:  IORLW  80
07FA:  MOVWF  5F
07FC:  CLRF   x60
07FE:  MOVWF  x61
0800:  RCALL  0150
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0802:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0804:  MOVF   5B,W
0806:  XORLW  07
0808:  BZ    0818
080A:  XORLW  0B
080C:  BZ    0822
080E:  XORLW  06
0810:  BZ    0832
0812:  XORLW  02
0814:  BZ    083E
0816:  BRA    0848
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0818:  MOVLW  01
081A:  MOVWF  5C
081C:  MOVWF  5D
081E:  RCALL  07E2
0820:  BRA    0852
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0822:  CLRF   x60
0824:  MOVLW  01
0826:  MOVWF  x61
0828:  RCALL  0150
....................                      delay_ms(2); 
082A:  MOVLW  02
082C:  MOVWF  5C
082E:  RCALL  004E
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0830:  BRA    0852
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0832:  MOVLW  01
0834:  MOVWF  5C
0836:  MOVLW  02
0838:  MOVWF  5D
083A:  RCALL  07E2
083C:  BRA    0852
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
083E:  CLRF   x60
0840:  MOVLW  10
0842:  MOVWF  x61
0844:  RCALL  0150
0846:  BRA    0852
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0848:  MOVLW  01
084A:  MOVWF  x60
084C:  MOVFF  5B,61
0850:  RCALL  0150
....................      #endif 
....................    } 
0852:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include<stdio.h> // Inclui o modo de entrada e saida do c 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... char temperature[] = " 00.0 C";// variavel que armazenara a temperatura 
.................... unsigned int16 temp;  
....................  
....................  
....................  
.................... float Valor_lido,tensao,tensao2,tensao3,corrente,corrente2,corrente3;// Variável tensão e corrente e valor temporario que será lido 
....................  
.................... int16 leitura_adc; 
....................  
.................... void ImprimiMenu(char temperature, float tensao,float tensao2, float tensao3, float corrente,float corrente2, float corrente3);// declaração da função  
....................  
....................  
....................  
.................... void ImprimiMenu(char temperature, float tensao,float tensao2, float tensao3, float corrente,float corrente2, float corrente3) 
.................... { 
....................     printf(lcd_putc,"\f"); 
*
0B00:  MOVLW  0C
0B02:  MOVWF  5B
0B04:  RCALL  0804
....................     lcd_gotoxy(1,1); 
0B06:  MOVLW  01
0B08:  MOVWF  5C
0B0A:  MOVWF  5D
0B0C:  RCALL  07E2
....................     printf(lcd_putc,"T2560"); 
0B0E:  MOVLW  18
0B10:  MOVWF  FF6
0B12:  MOVLW  00
0B14:  MOVWF  FF7
0B16:  BRA    0854
....................     lcd_gotoxy(7, 1);                             
0B18:  MOVLW  07
0B1A:  MOVWF  5C
0B1C:  MOVLW  01
0B1E:  MOVWF  5D
0B20:  RCALL  07E2
....................     printf(lcd_putc, temperature);  
0B22:  CLRF   FEA
0B24:  MOVFF  35,FE9
0B28:  BRA    0876
....................     delay_ms(100); 
0B2A:  MOVLW  64
0B2C:  MOVWF  5C
0B2E:  CALL   004E
....................     lcd_gotoxy(1,2); 
0B32:  MOVLW  01
0B34:  MOVWF  5C
0B36:  MOVLW  02
0B38:  MOVWF  5D
0B3A:  RCALL  07E2
....................     printf(lcd_putc,"F1:%.1fV %.1fA",tensao,corrente); 
0B3C:  MOVLW  1E
0B3E:  MOVWF  FF6
0B40:  MOVLW  00
0B42:  MOVWF  FF7
0B44:  MOVLW  03
0B46:  MOVWF  4E
0B48:  RCALL  089C
0B4A:  MOVLW  89
0B4C:  MOVWF  FE9
0B4E:  MOVFF  39,51
0B52:  MOVFF  38,50
0B56:  MOVFF  37,4F
0B5A:  MOVFF  36,4E
0B5E:  MOVLW  01
0B60:  MOVWF  52
0B62:  RCALL  0988
0B64:  MOVLW  56
0B66:  MOVWF  5B
0B68:  RCALL  0804
0B6A:  MOVLW  20
0B6C:  MOVWF  5B
0B6E:  RCALL  0804
0B70:  MOVLW  89
0B72:  MOVWF  FE9
0B74:  MOVFF  45,51
0B78:  MOVFF  44,50
0B7C:  MOVFF  43,4F
0B80:  MOVFF  42,4E
0B84:  MOVLW  01
0B86:  MOVWF  52
0B88:  RCALL  0988
0B8A:  MOVLW  41
0B8C:  MOVWF  5B
0B8E:  RCALL  0804
....................     delay_ms(100); 
0B90:  MOVLW  64
0B92:  MOVWF  5C
0B94:  CALL   004E
....................     lcd_gotoxy(17,1); 
0B98:  MOVLW  11
0B9A:  MOVWF  5C
0B9C:  MOVLW  01
0B9E:  MOVWF  5D
0BA0:  RCALL  07E2
....................     printf(lcd_putc,"F2:%.1fV %.1fA",tensao2,corrente2); 
0BA2:  MOVLW  2E
0BA4:  MOVWF  FF6
0BA6:  MOVLW  00
0BA8:  MOVWF  FF7
0BAA:  MOVLW  03
0BAC:  MOVWF  4E
0BAE:  RCALL  089C
0BB0:  MOVLW  89
0BB2:  MOVWF  FE9
0BB4:  MOVFF  3D,51
0BB8:  MOVFF  3C,50
0BBC:  MOVFF  3B,4F
0BC0:  MOVFF  3A,4E
0BC4:  MOVLW  01
0BC6:  MOVWF  52
0BC8:  RCALL  0988
0BCA:  MOVLW  56
0BCC:  MOVWF  5B
0BCE:  RCALL  0804
0BD0:  MOVLW  20
0BD2:  MOVWF  5B
0BD4:  RCALL  0804
0BD6:  MOVLW  89
0BD8:  MOVWF  FE9
0BDA:  MOVFF  49,51
0BDE:  MOVFF  48,50
0BE2:  MOVFF  47,4F
0BE6:  MOVFF  46,4E
0BEA:  MOVLW  01
0BEC:  MOVWF  52
0BEE:  RCALL  0988
0BF0:  MOVLW  41
0BF2:  MOVWF  5B
0BF4:  RCALL  0804
....................     delay_ms(100); 
0BF6:  MOVLW  64
0BF8:  MOVWF  5C
0BFA:  CALL   004E
....................     lcd_gotoxy(17,2); 
0BFE:  MOVLW  11
0C00:  MOVWF  5C
0C02:  MOVLW  02
0C04:  MOVWF  5D
0C06:  RCALL  07E2
....................     printf(lcd_putc,"F3:%.1fV %.1fA",tensao3,corrente3); 
0C08:  MOVLW  3E
0C0A:  MOVWF  FF6
0C0C:  MOVLW  00
0C0E:  MOVWF  FF7
0C10:  MOVLW  03
0C12:  MOVWF  4E
0C14:  RCALL  089C
0C16:  MOVLW  89
0C18:  MOVWF  FE9
0C1A:  MOVFF  41,51
0C1E:  MOVFF  40,50
0C22:  MOVFF  3F,4F
0C26:  MOVFF  3E,4E
0C2A:  MOVLW  01
0C2C:  MOVWF  52
0C2E:  RCALL  0988
0C30:  MOVLW  56
0C32:  MOVWF  5B
0C34:  RCALL  0804
0C36:  MOVLW  20
0C38:  MOVWF  5B
0C3A:  RCALL  0804
0C3C:  MOVLW  89
0C3E:  MOVWF  FE9
0C40:  MOVFF  4D,51
0C44:  MOVFF  4C,50
0C48:  MOVFF  4B,4F
0C4C:  MOVFF  4A,4E
0C50:  MOVLW  01
0C52:  MOVWF  52
0C54:  RCALL  0988
0C56:  MOVLW  41
0C58:  MOVWF  5B
0C5A:  RCALL  0804
....................     delay_ms(100); 
0C5C:  MOVLW  64
0C5E:  MOVWF  5C
0C60:  CALL   004E
0C64:  GOTO   14F0 (RETURN)
....................      
....................        
....................        
....................       
.................... }  
....................  
....................  
....................  
....................  
.................... int main() 
0C68:  CLRF   FF8
0C6A:  BCF    FD0.7
0C6C:  MOVLW  70
0C6E:  MOVWF  FD3
0C70:  MOVF   FD3,W
0C72:  BSF    F93.1
0C74:  BSF    F93.0
0C76:  MOVLW  13
0C78:  MOVWF  FC8
0C7A:  MOVLW  28
0C7C:  MOVWF  FC6
0C7E:  BSF    FC7.7
0C80:  BCF    FC7.6
0C82:  MOVF   FC1,W
0C84:  ANDLW  C0
0C86:  IORLW  0F
0C88:  MOVWF  FC1
0C8A:  MOVLW  07
0C8C:  MOVWF  FB4
0C8E:  CLRF   0B
0C90:  CLRF   0C
0C92:  MOVLW  20
0C94:  MOVWF  0D
0C96:  MOVLW  30
0C98:  MOVWF  0E
0C9A:  MOVWF  0F
0C9C:  MOVLW  2E
0C9E:  MOVWF  10
0CA0:  MOVLW  30
0CA2:  MOVWF  11
0CA4:  MOVLW  20
0CA6:  MOVWF  12
0CA8:  MOVLW  43
0CAA:  MOVWF  13
0CAC:  CLRF   14
.................... { 
....................     
....................    setup_adc(ADC_CLOCK_INTERNAL);                 // ADC Module uses its internal oscillator 
0CAE:  MOVF   FC0,W
0CB0:  ANDLW  C0
0CB2:  IORLW  07
0CB4:  MOVWF  FC0
0CB6:  BSF    FC0.7
0CB8:  BSF    FC2.0
....................    setup_adc_ports(AN0_to_AN6);                          // Configure AN0 pin as analog 
0CBA:  MOVF   FC1,W
0CBC:  ANDLW  C0
0CBE:  IORLW  08
0CC0:  MOVWF  FC1
....................      
....................     
....................    
....................    lcd_init();//inicia LCD 
0CC2:  GOTO   0196
....................    
....................   
....................    
....................    
....................     
....................    while(true) 
....................    { 
....................     
....................     
....................       set_adc_channel(0); 
0CC6:  MOVLW  00
0CC8:  MOVWF  01
0CCA:  MOVF   FC2,W
0CCC:  ANDLW  C3
0CCE:  IORWF  01,W
0CD0:  MOVWF  FC2
....................       delay_us(20); 
0CD2:  MOVLW  0C
0CD4:  MOVWF  00
0CD6:  DECFSZ 00,F
0CD8:  BRA    0CD6
0CDA:  BRA    0CDC
0CDC:  NOP   
....................       temp = read_adc() * 0.489;                   // Read analog voltage and convert it to degree celsius (0.489 = 500/1023) 
0CDE:  BSF    FC2.1
0CE0:  BTFSC  FC2.1
0CE2:  BRA    0CE0
0CE4:  MOVFF  FC4,03
0CE8:  MOVFF  FC3,35
0CEC:  MOVFF  FC4,36
0CF0:  MOVFF  FC4,38
0CF4:  MOVFF  FC3,37
0CF8:  CALL   0204
0CFC:  MOVFF  03,5E
0D00:  MOVFF  02,5D
0D04:  MOVFF  01,5C
0D08:  MOVFF  00,5B
0D0C:  MOVLW  35
0D0E:  MOVWF  x62
0D10:  MOVLW  5E
0D12:  MOVWF  x61
0D14:  MOVLW  7A
0D16:  MOVWF  x60
0D18:  MOVLW  7D
0D1A:  MOVWF  5F
0D1C:  CALL   023A
0D20:  MOVFF  03,38
0D24:  MOVFF  02,37
0D28:  MOVFF  01,36
0D2C:  MOVFF  00,35
0D30:  GOTO   032C
0D34:  MOVFF  02,16
0D38:  MOVFF  01,15
....................       if (temp > 99) 
0D3C:  MOVF   16,F
0D3E:  BNZ   0D46
0D40:  MOVF   15,W
0D42:  SUBLW  63
0D44:  BC    0D4C
....................          temperature[0]  = 1 + 48;                  // Put 1 (of hundred) 
0D46:  MOVLW  31
0D48:  MOVWF  0D
0D4A:  BRA    0D50
....................       else 
....................          temperature[0]  = ' ';                     // Put space 
0D4C:  MOVLW  20
0D4E:  MOVWF  0D
....................       temperature[1]  = (temp / 10) % 10  + 48; 
0D50:  MOVFF  16,38
0D54:  MOVFF  15,37
0D58:  CLRF   3A
0D5A:  MOVLW  0A
0D5C:  MOVWF  39
0D5E:  CALL   0366
0D62:  MOVFF  02,36
0D66:  MOVFF  01,35
0D6A:  MOVFF  02,38
0D6E:  MOVFF  01,37
0D72:  CLRF   3A
0D74:  MOVLW  0A
0D76:  MOVWF  39
0D78:  CALL   0366
0D7C:  MOVLW  30
0D7E:  ADDWF  00,W
0D80:  MOVWF  0E
....................       temperature[2]  =  temp % 10  + 48; 
0D82:  MOVFF  16,38
0D86:  MOVFF  15,37
0D8A:  CLRF   3A
0D8C:  MOVLW  0A
0D8E:  MOVWF  39
0D90:  CALL   0366
0D94:  MOVLW  30
0D96:  ADDWF  00,W
0D98:  MOVWF  0F
....................       temperature[5] = 223;  
0D9A:  MOVLW  DF
0D9C:  MOVWF  12
....................        
....................       set_adc_channel(1); 
0D9E:  MOVLW  04
0DA0:  MOVWF  01
0DA2:  MOVF   FC2,W
0DA4:  ANDLW  C3
0DA6:  IORWF  01,W
0DA8:  MOVWF  FC2
....................          
....................       leitura_adc=read_adc(); 
0DAA:  BSF    FC2.1
0DAC:  BTFSC  FC2.1
0DAE:  BRA    0DAC
0DB0:  MOVFF  FC3,33
0DB4:  MOVFF  FC4,34
....................        
....................       //Conversão de tipo de variável (Nunca acredite em AJUSTE DE TIPO automático) 
....................       Valor_lido=(float)leitura_adc;  
0DB8:  MOVFF  34,38
0DBC:  MOVFF  33,37
0DC0:  CALL   0204
0DC4:  MOVFF  03,1A
0DC8:  MOVFF  02,19
0DCC:  MOVFF  01,18
0DD0:  MOVFF  00,17
....................       tensao=((Valor_lido*5*60)/1023)+1 ;  
0DD4:  MOVFF  1A,5E
0DD8:  MOVFF  19,5D
0DDC:  MOVFF  18,5C
0DE0:  MOVFF  17,5B
0DE4:  CLRF   x62
0DE6:  CLRF   x61
0DE8:  MOVLW  20
0DEA:  MOVWF  x60
0DEC:  MOVLW  81
0DEE:  MOVWF  5F
0DF0:  CALL   023A
0DF4:  MOVFF  03,38
0DF8:  MOVFF  02,37
0DFC:  MOVFF  01,36
0E00:  MOVFF  00,35
0E04:  MOVFF  03,5E
0E08:  MOVFF  02,5D
0E0C:  MOVFF  01,5C
0E10:  MOVFF  00,5B
0E14:  CLRF   x62
0E16:  CLRF   x61
0E18:  MOVLW  70
0E1A:  MOVWF  x60
0E1C:  MOVLW  84
0E1E:  MOVWF  5F
0E20:  CALL   023A
0E24:  MOVFF  03,38
0E28:  MOVFF  02,37
0E2C:  MOVFF  01,36
0E30:  MOVFF  00,35
0E34:  MOVFF  03,3C
0E38:  MOVFF  02,3B
0E3C:  MOVFF  01,3A
0E40:  MOVFF  00,39
0E44:  CLRF   40
0E46:  MOVLW  C0
0E48:  MOVWF  3F
0E4A:  MOVLW  7F
0E4C:  MOVWF  3E
0E4E:  MOVLW  88
0E50:  MOVWF  3D
0E52:  CALL   03A8
0E56:  MOVFF  03,38
0E5A:  MOVFF  02,37
0E5E:  MOVFF  01,36
0E62:  MOVFF  00,35
0E66:  BCF    FD8.1
0E68:  MOVFF  03,3C
0E6C:  MOVFF  02,3B
0E70:  MOVFF  01,3A
0E74:  MOVFF  00,39
0E78:  CLRF   40
0E7A:  CLRF   3F
0E7C:  CLRF   3E
0E7E:  MOVLW  7F
0E80:  MOVWF  3D
0E82:  CALL   0502
0E86:  MOVFF  03,1E
0E8A:  MOVFF  02,1D
0E8E:  MOVFF  01,1C
0E92:  MOVFF  00,1B
....................        
....................       set_adc_channel(2); 
0E96:  MOVLW  08
0E98:  MOVWF  01
0E9A:  MOVF   FC2,W
0E9C:  ANDLW  C3
0E9E:  IORWF  01,W
0EA0:  MOVWF  FC2
....................        
....................       leitura_adc=read_adc(); 
0EA2:  BSF    FC2.1
0EA4:  BTFSC  FC2.1
0EA6:  BRA    0EA4
0EA8:  MOVFF  FC3,33
0EAC:  MOVFF  FC4,34
....................        
....................       //Conversão de tipo de variável (Nunca acredite em AJUSTE DE TIPO automático) 
....................       Valor_lido=(float)leitura_adc;  
0EB0:  MOVFF  34,38
0EB4:  MOVFF  33,37
0EB8:  CALL   0204
0EBC:  MOVFF  03,1A
0EC0:  MOVFF  02,19
0EC4:  MOVFF  01,18
0EC8:  MOVFF  00,17
....................       tensao2=((Valor_lido*5*60)/1023)+1 ; 
0ECC:  MOVFF  1A,5E
0ED0:  MOVFF  19,5D
0ED4:  MOVFF  18,5C
0ED8:  MOVFF  17,5B
0EDC:  CLRF   x62
0EDE:  CLRF   x61
0EE0:  MOVLW  20
0EE2:  MOVWF  x60
0EE4:  MOVLW  81
0EE6:  MOVWF  5F
0EE8:  CALL   023A
0EEC:  MOVFF  03,38
0EF0:  MOVFF  02,37
0EF4:  MOVFF  01,36
0EF8:  MOVFF  00,35
0EFC:  MOVFF  03,5E
0F00:  MOVFF  02,5D
0F04:  MOVFF  01,5C
0F08:  MOVFF  00,5B
0F0C:  CLRF   x62
0F0E:  CLRF   x61
0F10:  MOVLW  70
0F12:  MOVWF  x60
0F14:  MOVLW  84
0F16:  MOVWF  5F
0F18:  CALL   023A
0F1C:  MOVFF  03,38
0F20:  MOVFF  02,37
0F24:  MOVFF  01,36
0F28:  MOVFF  00,35
0F2C:  MOVFF  03,3C
0F30:  MOVFF  02,3B
0F34:  MOVFF  01,3A
0F38:  MOVFF  00,39
0F3C:  CLRF   40
0F3E:  MOVLW  C0
0F40:  MOVWF  3F
0F42:  MOVLW  7F
0F44:  MOVWF  3E
0F46:  MOVLW  88
0F48:  MOVWF  3D
0F4A:  CALL   03A8
0F4E:  MOVFF  03,38
0F52:  MOVFF  02,37
0F56:  MOVFF  01,36
0F5A:  MOVFF  00,35
0F5E:  BCF    FD8.1
0F60:  MOVFF  03,3C
0F64:  MOVFF  02,3B
0F68:  MOVFF  01,3A
0F6C:  MOVFF  00,39
0F70:  CLRF   40
0F72:  CLRF   3F
0F74:  CLRF   3E
0F76:  MOVLW  7F
0F78:  MOVWF  3D
0F7A:  CALL   0502
0F7E:  MOVFF  03,22
0F82:  MOVFF  02,21
0F86:  MOVFF  01,20
0F8A:  MOVFF  00,1F
....................        
....................       set_adc_channel(3); 
0F8E:  MOVLW  0C
0F90:  MOVWF  01
0F92:  MOVF   FC2,W
0F94:  ANDLW  C3
0F96:  IORWF  01,W
0F98:  MOVWF  FC2
....................     
....................       leitura_adc=read_adc(); 
0F9A:  BSF    FC2.1
0F9C:  BTFSC  FC2.1
0F9E:  BRA    0F9C
0FA0:  MOVFF  FC3,33
0FA4:  MOVFF  FC4,34
....................        
....................       //Conversão de tipo de variável (Nunca acredite em AJUSTE DE TIPO automático) 
....................       Valor_lido=(float)leitura_adc;  
0FA8:  MOVFF  34,38
0FAC:  MOVFF  33,37
0FB0:  CALL   0204
0FB4:  MOVFF  03,1A
0FB8:  MOVFF  02,19
0FBC:  MOVFF  01,18
0FC0:  MOVFF  00,17
....................       tensao3=((Valor_lido*5*60)/1023)+1 ;  
0FC4:  MOVFF  1A,5E
0FC8:  MOVFF  19,5D
0FCC:  MOVFF  18,5C
0FD0:  MOVFF  17,5B
0FD4:  CLRF   x62
0FD6:  CLRF   x61
0FD8:  MOVLW  20
0FDA:  MOVWF  x60
0FDC:  MOVLW  81
0FDE:  MOVWF  5F
0FE0:  CALL   023A
0FE4:  MOVFF  03,38
0FE8:  MOVFF  02,37
0FEC:  MOVFF  01,36
0FF0:  MOVFF  00,35
0FF4:  MOVFF  03,5E
0FF8:  MOVFF  02,5D
0FFC:  MOVFF  01,5C
1000:  MOVFF  00,5B
1004:  CLRF   x62
1006:  CLRF   x61
1008:  MOVLW  70
100A:  MOVWF  x60
100C:  MOVLW  84
100E:  MOVWF  5F
1010:  CALL   023A
1014:  MOVFF  03,38
1018:  MOVFF  02,37
101C:  MOVFF  01,36
1020:  MOVFF  00,35
1024:  MOVFF  03,3C
1028:  MOVFF  02,3B
102C:  MOVFF  01,3A
1030:  MOVFF  00,39
1034:  CLRF   40
1036:  MOVLW  C0
1038:  MOVWF  3F
103A:  MOVLW  7F
103C:  MOVWF  3E
103E:  MOVLW  88
1040:  MOVWF  3D
1042:  CALL   03A8
1046:  MOVFF  03,38
104A:  MOVFF  02,37
104E:  MOVFF  01,36
1052:  MOVFF  00,35
1056:  BCF    FD8.1
1058:  MOVFF  03,3C
105C:  MOVFF  02,3B
1060:  MOVFF  01,3A
1064:  MOVFF  00,39
1068:  CLRF   40
106A:  CLRF   3F
106C:  CLRF   3E
106E:  MOVLW  7F
1070:  MOVWF  3D
1072:  CALL   0502
1076:  MOVFF  03,26
107A:  MOVFF  02,25
107E:  MOVFF  01,24
1082:  MOVFF  00,23
....................         
....................       set_adc_channel(4); 
1086:  MOVLW  10
1088:  MOVWF  01
108A:  MOVF   FC2,W
108C:  ANDLW  C3
108E:  IORWF  01,W
1090:  MOVWF  FC2
....................     
....................       leitura_adc=read_adc(); 
1092:  BSF    FC2.1
1094:  BTFSC  FC2.1
1096:  BRA    1094
1098:  MOVFF  FC3,33
109C:  MOVFF  FC4,34
....................        
....................       //Conversão de tipo de variável (Nunca acredite em AJUSTE DE TIPO automático) 
....................       Valor_lido=(float)leitura_adc;  
10A0:  MOVFF  34,38
10A4:  MOVFF  33,37
10A8:  CALL   0204
10AC:  MOVFF  03,1A
10B0:  MOVFF  02,19
10B4:  MOVFF  01,18
10B8:  MOVFF  00,17
....................       corrente=(((Valor_lido*5)/1023)-2.5)/0.185 ; 
10BC:  MOVFF  1A,5E
10C0:  MOVFF  19,5D
10C4:  MOVFF  18,5C
10C8:  MOVFF  17,5B
10CC:  CLRF   x62
10CE:  CLRF   x61
10D0:  MOVLW  20
10D2:  MOVWF  x60
10D4:  MOVLW  81
10D6:  MOVWF  5F
10D8:  CALL   023A
10DC:  MOVFF  03,38
10E0:  MOVFF  02,37
10E4:  MOVFF  01,36
10E8:  MOVFF  00,35
10EC:  MOVFF  03,3C
10F0:  MOVFF  02,3B
10F4:  MOVFF  01,3A
10F8:  MOVFF  00,39
10FC:  CLRF   40
10FE:  MOVLW  C0
1100:  MOVWF  3F
1102:  MOVLW  7F
1104:  MOVWF  3E
1106:  MOVLW  88
1108:  MOVWF  3D
110A:  CALL   03A8
110E:  MOVFF  03,38
1112:  MOVFF  02,37
1116:  MOVFF  01,36
111A:  MOVFF  00,35
111E:  BSF    FD8.1
1120:  MOVFF  03,3C
1124:  MOVFF  02,3B
1128:  MOVFF  01,3A
112C:  MOVFF  00,39
1130:  CLRF   40
1132:  CLRF   3F
1134:  MOVLW  20
1136:  MOVWF  3E
1138:  MOVLW  80
113A:  MOVWF  3D
113C:  CALL   0502
1140:  MOVFF  03,38
1144:  MOVFF  02,37
1148:  MOVFF  01,36
114C:  MOVFF  00,35
1150:  MOVFF  03,3C
1154:  MOVFF  02,3B
1158:  MOVFF  01,3A
115C:  MOVFF  00,39
1160:  MOVLW  A4
1162:  MOVWF  40
1164:  MOVLW  70
1166:  MOVWF  3F
1168:  MOVLW  3D
116A:  MOVWF  3E
116C:  MOVLW  7C
116E:  MOVWF  3D
1170:  CALL   03A8
1174:  MOVFF  03,2A
1178:  MOVFF  02,29
117C:  MOVFF  01,28
1180:  MOVFF  00,27
....................        if(corrente>=1) 
1184:  CLRF   38
1186:  CLRF   37
1188:  CLRF   36
118A:  MOVLW  7F
118C:  MOVWF  35
118E:  MOVFF  2A,3C
1192:  MOVFF  29,3B
1196:  MOVFF  28,3A
119A:  MOVFF  27,39
119E:  CALL   076C
11A2:  BC    11A6
11A4:  BNZ   11DC
....................          corrente = corrente -0.1; 
11A6:  BSF    FD8.1
11A8:  MOVFF  2A,3C
11AC:  MOVFF  29,3B
11B0:  MOVFF  28,3A
11B4:  MOVFF  27,39
11B8:  MOVLW  CD
11BA:  MOVWF  40
11BC:  MOVLW  CC
11BE:  MOVWF  3F
11C0:  MOVLW  4C
11C2:  MOVWF  3E
11C4:  MOVLW  7B
11C6:  MOVWF  3D
11C8:  CALL   0502
11CC:  MOVFF  03,2A
11D0:  MOVFF  02,29
11D4:  MOVFF  01,28
11D8:  MOVFF  00,27
....................        set_adc_channel(5); 
11DC:  MOVLW  14
11DE:  MOVWF  01
11E0:  MOVF   FC2,W
11E2:  ANDLW  C3
11E4:  IORWF  01,W
11E6:  MOVWF  FC2
....................     
....................       leitura_adc=read_adc(); 
11E8:  BSF    FC2.1
11EA:  BTFSC  FC2.1
11EC:  BRA    11EA
11EE:  MOVFF  FC3,33
11F2:  MOVFF  FC4,34
....................        
....................       //Conversão de tipo de variável (Nunca acredite em AJUSTE DE TIPO automático) 
....................       Valor_lido=(float)leitura_adc;  
11F6:  MOVFF  34,38
11FA:  MOVFF  33,37
11FE:  CALL   0204
1202:  MOVFF  03,1A
1206:  MOVFF  02,19
120A:  MOVFF  01,18
120E:  MOVFF  00,17
....................       corrente2=(((Valor_lido*5)/1023)-2.5)/0.185 ; 
1212:  MOVFF  1A,5E
1216:  MOVFF  19,5D
121A:  MOVFF  18,5C
121E:  MOVFF  17,5B
1222:  CLRF   x62
1224:  CLRF   x61
1226:  MOVLW  20
1228:  MOVWF  x60
122A:  MOVLW  81
122C:  MOVWF  5F
122E:  CALL   023A
1232:  MOVFF  03,38
1236:  MOVFF  02,37
123A:  MOVFF  01,36
123E:  MOVFF  00,35
1242:  MOVFF  03,3C
1246:  MOVFF  02,3B
124A:  MOVFF  01,3A
124E:  MOVFF  00,39
1252:  CLRF   40
1254:  MOVLW  C0
1256:  MOVWF  3F
1258:  MOVLW  7F
125A:  MOVWF  3E
125C:  MOVLW  88
125E:  MOVWF  3D
1260:  CALL   03A8
1264:  MOVFF  03,38
1268:  MOVFF  02,37
126C:  MOVFF  01,36
1270:  MOVFF  00,35
1274:  BSF    FD8.1
1276:  MOVFF  03,3C
127A:  MOVFF  02,3B
127E:  MOVFF  01,3A
1282:  MOVFF  00,39
1286:  CLRF   40
1288:  CLRF   3F
128A:  MOVLW  20
128C:  MOVWF  3E
128E:  MOVLW  80
1290:  MOVWF  3D
1292:  CALL   0502
1296:  MOVFF  03,38
129A:  MOVFF  02,37
129E:  MOVFF  01,36
12A2:  MOVFF  00,35
12A6:  MOVFF  03,3C
12AA:  MOVFF  02,3B
12AE:  MOVFF  01,3A
12B2:  MOVFF  00,39
12B6:  MOVLW  A4
12B8:  MOVWF  40
12BA:  MOVLW  70
12BC:  MOVWF  3F
12BE:  MOVLW  3D
12C0:  MOVWF  3E
12C2:  MOVLW  7C
12C4:  MOVWF  3D
12C6:  CALL   03A8
12CA:  MOVFF  03,2E
12CE:  MOVFF  02,2D
12D2:  MOVFF  01,2C
12D6:  MOVFF  00,2B
....................       if(corrente2>=1) 
12DA:  CLRF   38
12DC:  CLRF   37
12DE:  CLRF   36
12E0:  MOVLW  7F
12E2:  MOVWF  35
12E4:  MOVFF  2E,3C
12E8:  MOVFF  2D,3B
12EC:  MOVFF  2C,3A
12F0:  MOVFF  2B,39
12F4:  CALL   076C
12F8:  BC    12FC
12FA:  BNZ   1332
....................          corrente2 = corrente2 -0.1; 
12FC:  BSF    FD8.1
12FE:  MOVFF  2E,3C
1302:  MOVFF  2D,3B
1306:  MOVFF  2C,3A
130A:  MOVFF  2B,39
130E:  MOVLW  CD
1310:  MOVWF  40
1312:  MOVLW  CC
1314:  MOVWF  3F
1316:  MOVLW  4C
1318:  MOVWF  3E
131A:  MOVLW  7B
131C:  MOVWF  3D
131E:  CALL   0502
1322:  MOVFF  03,2E
1326:  MOVFF  02,2D
132A:  MOVFF  01,2C
132E:  MOVFF  00,2B
....................        
....................       set_adc_channel(6); 
1332:  MOVLW  18
1334:  MOVWF  01
1336:  MOVF   FC2,W
1338:  ANDLW  C3
133A:  IORWF  01,W
133C:  MOVWF  FC2
....................     
....................       leitura_adc=read_adc(); 
133E:  BSF    FC2.1
1340:  BTFSC  FC2.1
1342:  BRA    1340
1344:  MOVFF  FC3,33
1348:  MOVFF  FC4,34
....................        
....................       //Conversão de tipo de variável (Nunca acredite em AJUSTE DE TIPO automático) 
....................       Valor_lido=(float)leitura_adc;  
134C:  MOVFF  34,38
1350:  MOVFF  33,37
1354:  CALL   0204
1358:  MOVFF  03,1A
135C:  MOVFF  02,19
1360:  MOVFF  01,18
1364:  MOVFF  00,17
....................       corrente3=(((Valor_lido*5)/1023)-2.5)/0.185 ; 
1368:  MOVFF  1A,5E
136C:  MOVFF  19,5D
1370:  MOVFF  18,5C
1374:  MOVFF  17,5B
1378:  CLRF   x62
137A:  CLRF   x61
137C:  MOVLW  20
137E:  MOVWF  x60
1380:  MOVLW  81
1382:  MOVWF  5F
1384:  CALL   023A
1388:  MOVFF  03,38
138C:  MOVFF  02,37
1390:  MOVFF  01,36
1394:  MOVFF  00,35
1398:  MOVFF  03,3C
139C:  MOVFF  02,3B
13A0:  MOVFF  01,3A
13A4:  MOVFF  00,39
13A8:  CLRF   40
13AA:  MOVLW  C0
13AC:  MOVWF  3F
13AE:  MOVLW  7F
13B0:  MOVWF  3E
13B2:  MOVLW  88
13B4:  MOVWF  3D
13B6:  CALL   03A8
13BA:  MOVFF  03,38
13BE:  MOVFF  02,37
13C2:  MOVFF  01,36
13C6:  MOVFF  00,35
13CA:  BSF    FD8.1
13CC:  MOVFF  03,3C
13D0:  MOVFF  02,3B
13D4:  MOVFF  01,3A
13D8:  MOVFF  00,39
13DC:  CLRF   40
13DE:  CLRF   3F
13E0:  MOVLW  20
13E2:  MOVWF  3E
13E4:  MOVLW  80
13E6:  MOVWF  3D
13E8:  CALL   0502
13EC:  MOVFF  03,38
13F0:  MOVFF  02,37
13F4:  MOVFF  01,36
13F8:  MOVFF  00,35
13FC:  MOVFF  03,3C
1400:  MOVFF  02,3B
1404:  MOVFF  01,3A
1408:  MOVFF  00,39
140C:  MOVLW  A4
140E:  MOVWF  40
1410:  MOVLW  70
1412:  MOVWF  3F
1414:  MOVLW  3D
1416:  MOVWF  3E
1418:  MOVLW  7C
141A:  MOVWF  3D
141C:  CALL   03A8
1420:  MOVFF  03,32
1424:  MOVFF  02,31
1428:  MOVFF  01,30
142C:  MOVFF  00,2F
....................       if(corrente3>=1) 
1430:  CLRF   38
1432:  CLRF   37
1434:  CLRF   36
1436:  MOVLW  7F
1438:  MOVWF  35
143A:  MOVFF  32,3C
143E:  MOVFF  31,3B
1442:  MOVFF  30,3A
1446:  MOVFF  2F,39
144A:  CALL   076C
144E:  BC    1452
1450:  BNZ   1488
....................          corrente3 = corrente3 -0.1; 
1452:  BSF    FD8.1
1454:  MOVFF  32,3C
1458:  MOVFF  31,3B
145C:  MOVFF  30,3A
1460:  MOVFF  2F,39
1464:  MOVLW  CD
1466:  MOVWF  40
1468:  MOVLW  CC
146A:  MOVWF  3F
146C:  MOVLW  4C
146E:  MOVWF  3E
1470:  MOVLW  7B
1472:  MOVWF  3D
1474:  CALL   0502
1478:  MOVFF  03,32
147C:  MOVFF  02,31
1480:  MOVFF  01,30
1484:  MOVFF  00,2F
....................        
....................       ImprimiMenu(temperature,tensao,tensao2,tensao3,corrente,corrente2,corrente3); 
1488:  MOVLW  0D
148A:  MOVWF  35
148C:  MOVFF  1E,39
1490:  MOVFF  1D,38
1494:  MOVFF  1C,37
1498:  MOVFF  1B,36
149C:  MOVFF  22,3D
14A0:  MOVFF  21,3C
14A4:  MOVFF  20,3B
14A8:  MOVFF  1F,3A
14AC:  MOVFF  26,41
14B0:  MOVFF  25,40
14B4:  MOVFF  24,3F
14B8:  MOVFF  23,3E
14BC:  MOVFF  2A,45
14C0:  MOVFF  29,44
14C4:  MOVFF  28,43
14C8:  MOVFF  27,42
14CC:  MOVFF  2E,49
14D0:  MOVFF  2D,48
14D4:  MOVFF  2C,47
14D8:  MOVFF  2B,46
14DC:  MOVFF  32,4D
14E0:  MOVFF  31,4C
14E4:  MOVFF  30,4B
14E8:  MOVFF  2F,4A
14EC:  GOTO   0B00
....................       delay_ms(200); 
14F0:  MOVLW  C8
14F2:  MOVWF  5C
14F4:  CALL   004E
14F8:  GOTO   0CC6
....................    } 
.................... return 0; 
14FC:  MOVLW  00
14FE:  MOVWF  01
.................... } 
....................  
1500:  SLEEP 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: C93F   PLL12 CPUDIV4 USBDIV INTRC FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
